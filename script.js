#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { performance } = require('perf_hooks');

// Î≤§ÏπòÎßàÌÅ¨ ÏÑ§Ï†ï
const CONFIG = {
  fileCount: 10000,
  outputDir: './benchmark_files',
  babelOutputDir: './babel_output',
  swcOutputDir: './swc_output'
};

// Í∞ÄÏßú TypeScript ÌååÏùº ÏÉùÏÑ±
function generateFakeTypescriptFiles() {
  console.log(`üî® ${CONFIG.fileCount}Í∞úÏùò Í∞ÄÏßú TypeScript ÌååÏùº ÏÉùÏÑ± Ï§ë...`);
  
  // ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  if (fs.existsSync(CONFIG.outputDir)) {
    fs.rmSync(CONFIG.outputDir, { recursive: true });
  }
  fs.mkdirSync(CONFIG.outputDir, { recursive: true });

  const templates = [
    // React Ïª¥Ìè¨ÎÑåÌä∏ ÌÖúÌîåÎ¶ø
    (index) => `
import React, { useState, useEffect } from 'react';

interface User${index} {
  id: number;
  name: string;
  email: string;
  posts: Post${index}[];
}

interface Post${index} {
  id: number;
  title: string;
  content: string;
  author: User${index};
  tags: string[];
}

const UserCard${index}: React.FC<{ user: User${index} }> = ({ user }) => {
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [posts, setPosts] = useState<Post${index}[]>([]);

  useEffect(() => {
    const fetchPosts = async () => {
      setIsLoading(true);
      try {
        const response = await fetch(\`/api/users/\${user.id}/posts\`);
        const data: Post${index}[] = await response.json();
        setPosts(data);
      } catch (error) {
        console.error('Failed to fetch posts:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchPosts();
  }, [user.id]);

  const handlePostClick = (post: Post${index}) => {
    console.log(\`Clicked post: \${post.title}\`);
  };

  return (
    <div className="user-card">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      {isLoading ? (
        <div>Loading posts...</div>
      ) : (
        <div>
          {posts.map((post) => (
            <div key={post.id} onClick={() => handlePostClick(post)}>
              <h3>{post.title}</h3>
              <p>{post.content}</p>
              <div>
                {post.tags.map((tag) => (
                  <span key={tag} className="tag">{tag}</span>
                ))}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default UserCard${index};
`,

    // ÏÑúÎπÑÏä§ ÌÅ¥ÎûòÏä§ ÌÖúÌîåÎ¶ø
    (index) => `
export class DataService${index}<T> {
  private cache: Map<string, T> = new Map();
  private readonly apiUrl: string;

  constructor(apiUrl: string) {
    this.apiUrl = apiUrl;
  }

  async get<K extends keyof T>(id: string): Promise<T | null> {
    if (this.cache.has(id)) {
      return this.cache.get(id)!;
    }

    try {
      const response = await fetch(\`\${this.apiUrl}/\${id}\`);
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }
      
      const data: T = await response.json();
      this.cache.set(id, data);
      return data;
    } catch (error) {
      console.error(\`Failed to fetch data for id \${id}:\`, error);
      return null;
    }
  }

  async getAll(): Promise<T[]> {
    try {
      const response = await fetch(this.apiUrl);
      const data: T[] = await response.json();
      
      data.forEach((item: any) => {
        if (item.id) {
          this.cache.set(item.id, item);
        }
      });
      
      return data;
    } catch (error) {
      console.error('Failed to fetch all data:', error);
      return [];
    }
  }

  async create(data: Omit<T, 'id'>): Promise<T | null> {
    try {
      const response = await fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const newItem: T = await response.json();
      if ((newItem as any).id) {
        this.cache.set((newItem as any).id, newItem);
      }
      
      return newItem;
    } catch (error) {
      console.error('Failed to create data:', error);
      return null;
    }
  }

  clearCache(): void {
    this.cache.clear();
  }

  getCacheSize(): number {
    return this.cache.size;
  }
}

export const userService${index} = new DataService${index}<{
  id: string;
  name: string;
  email: string;
}>('/api/users');
`,

    // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ÌÖúÌîåÎ¶ø
    (index) => `
export interface Config${index} {
  apiUrl: string;
  timeout: number;
  retries: number;
  enableCache: boolean;
}

export type DeepPartial${index}<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial${index}<T[P]> : T[P];
};

export const defaultConfig${index}: Config${index} = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retries: 3,
  enableCache: true,
};

export function mergeConfig${index}<T extends Config${index}>(
  base: T,
  override: DeepPartial${index}<T>
): T {
  const result = { ...base };
  
  for (const key in override) {
    if (override[key] !== undefined) {
      if (typeof override[key] === 'object' && override[key] !== null) {
        result[key] = mergeConfig${index}(
          result[key] as any,
          override[key] as any
        );
      } else {
        (result as any)[key] = override[key];
      }
    }
  }
  
  return result;
}

export async function retry${index}<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt === maxRetries) {
        break;
      }
      
      await new Promise(resolve => setTimeout(resolve, delay * attempt));
    }
  }
  
  throw lastError!;
}

export function debounce${index}<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeout) {
      clearTimeout(timeout);
    }
    
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
}

export class EventEmitter${index}<T extends Record<string, any[]>> {
  private listeners: { [K in keyof T]?: ((...args: T[K]) => void)[] } = {};

  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }

  emit<K extends keyof T>(event: K, ...args: T[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(...args));
    }
  }

  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      const index = eventListeners.indexOf(listener);
      if (index > -1) {
        eventListeners.splice(index, 1);
      }
    }
  }
}
`
  ];

  // ÌååÏùº ÏÉùÏÑ±
  for (let i = 0; i < CONFIG.fileCount; i++) {
    const template = templates[i % templates.length];
    const content = template(i);
    const filename = `file${i.toString().padStart(5, '0')}.tsx`;
    const filepath = path.join(CONFIG.outputDir, filename);
    
    fs.writeFileSync(filepath, content);
    
    if ((i + 1) % 1000 === 0) {
      console.log(`  ‚úÖ ${i + 1}/${CONFIG.fileCount} ÌååÏùº ÏÉùÏÑ± ÏôÑÎ£å`);
    }
  }
  
  console.log(`‚úÖ Ï¥ù ${CONFIG.fileCount}Í∞ú ÌååÏùº ÏÉùÏÑ± ÏôÑÎ£å!\n`);
}


// BabelÎ°ú Î≥ÄÌôò
async function benchmarkBabel() {
  console.log('2. Babel Î≤§ÏπòÎßàÌÅ¨ ÏãúÏûë...');

  // Babel ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±
  const babelConfig = {
    presets: [
      '@babel/preset-env',
      '@babel/preset-react',
      '@babel/preset-typescript'
    ],
    plugins: [
      '@babel/plugin-transform-class-properties',
      '@babel/plugin-transform-runtime'
    ]
  };
  
  fs.writeFileSync('./babel.config.json', JSON.stringify(babelConfig, null, 2));
  
  // Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  if (fs.existsSync(CONFIG.babelOutputDir)) {
    fs.rmSync(CONFIG.babelOutputDir, { recursive: true });
  }
  fs.mkdirSync(CONFIG.babelOutputDir, { recursive: true });

  console.log(`  üìÇ ${CONFIG.fileCount}Í∞ú ÌååÏùº Î≥ÄÌôò ÏãúÏûë...`);
  const startTime = performance.now();
  
  try {
    const command = `npx babel ${CONFIG.outputDir} --out-dir ${CONFIG.babelOutputDir} --extensions .tsx,.ts --source-maps`;
    
    console.log(`  ‚öôÔ∏è  Ïã§Ìñâ: ${command}`);
    
    execSync(command, { 
      stdio: 'pipe', // Ï∂úÎ†• Ïà®ÍπÄ (ÍπîÎÅîÌïú Í≤∞Í≥ºÎ•º ÏúÑÌï¥)
      encoding: 'utf8'
    });
    
    const endTime = performance.now();
    const duration = Math.round(endTime - startTime);
    
    console.log(`  ‚úÖ Babel ÏôÑÎ£å! ÏÜåÏöîÏãúÍ∞Ñ: ${(duration / 1000).toFixed(1)}Ï¥à`);
    
    return {
      name: 'Babel (JavaScript)',
      duration: duration,
      filesProcessed: CONFIG.fileCount
    };
  } catch (error) {
    console.error('  ‚ùå Babel Î≥ÄÌôò Ïã§Ìå®:', error.message);
    return null;
  }
}

// SWCÎ°ú Î≥ÄÌôò
async function benchmarkSWC() {
  console.log('3. SWC Î≤§ÏπòÎßàÌÅ¨ ÏãúÏûë...');
  
  // SWC ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±
  const swcConfig = {
    jsc: {
      parser: {
        syntax: 'typescript',
        tsx: true,
        decorators: false,
        dynamicImport: false
      },
      transform: {
        react: {
          pragma: 'React.createElement',
          pragmaFrag: 'React.Fragment',
          throwIfNamespace: true,
          development: false,
          useBuiltins: false
        }
      },
      target: 'es2018'
    },
    module: {
      type: 'commonjs'
    },
    sourceMaps: true
  };
  
  fs.writeFileSync('./.swcrc', JSON.stringify(swcConfig, null, 2));
  
  // Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  if (fs.existsSync(CONFIG.swcOutputDir)) {
    fs.rmSync(CONFIG.swcOutputDir, { recursive: true });
  }
  fs.mkdirSync(CONFIG.swcOutputDir, { recursive: true });

  console.log(`  üìÇ ${CONFIG.fileCount}Í∞ú ÌååÏùº Î≥ÄÌôò ÏãúÏûë...`);
  const startTime = performance.now();
  
  try {
    const command = `npx swc ${CONFIG.outputDir} -d ${CONFIG.swcOutputDir} --source-maps`;
    
    console.log(`  ‚öôÔ∏è  Ïã§Ìñâ: ${command}`);
    
    execSync(command, { 
      stdio: 'pipe', // Ï∂úÎ†• Ïà®ÍπÄ (ÍπîÎÅîÌïú Í≤∞Í≥ºÎ•º ÏúÑÌï¥)
      encoding: 'utf8'
    });
    
    const endTime = performance.now();
    const duration = Math.round(endTime - startTime);
    
    console.log(`  ‚úÖ SWC ÏôÑÎ£å! ÏÜåÏöîÏãúÍ∞Ñ: ${(duration / 1000).toFixed(1)}Ï¥à`);
    
    return {
      name: 'SWC (Rust)',
      duration: duration,
      filesProcessed: CONFIG.fileCount
    };
  } catch (error) {
    console.error('  ‚ùå SWC Î≥ÄÌôò Ïã§Ìå®:', error.message);
    return null;
  }
}

// Í≤∞Í≥º Ï∂úÎ†•
function printResults(babelResult, swcResult) {
  console.log('\n' + '='.repeat(60));
  console.log('üèÅ ÏÑ±Îä• ÎπÑÍµê Í≤∞Í≥º');
  console.log('='.repeat(60));
  
  if (babelResult) {
    console.log(`\nüî• ${babelResult.name}`);
    console.log(`   ‚è±Ô∏è  ÏÜåÏöîÏãúÍ∞Ñ: ${(babelResult.duration / 1000).toFixed(1)}Ï¥à`);
    console.log(`   üìÅ Ï≤òÎ¶¨ÌååÏùº: ${babelResult.filesProcessed.toLocaleString()}Í∞ú`);
    console.log(`   ‚ö° Ï≤òÎ¶¨ÏÜçÎèÑ: ${Math.round(babelResult.filesProcessed / (babelResult.duration / 1000)).toLocaleString()}Í∞ú/Ï¥à`);
  }
  
  if (swcResult) {
    console.log(`\n‚ö° ${swcResult.name}`);
    console.log(`   ‚è±Ô∏è  ÏÜåÏöîÏãúÍ∞Ñ: ${(swcResult.duration / 1000).toFixed(1)}Ï¥à`);
    console.log(`   üìÅ Ï≤òÎ¶¨ÌååÏùº: ${swcResult.filesProcessed.toLocaleString()}Í∞ú`);
    console.log(`   ‚ö° Ï≤òÎ¶¨ÏÜçÎèÑ: ${Math.round(swcResult.filesProcessed / (swcResult.duration / 1000)).toLocaleString()}Í∞ú/Ï¥à`);
  }
  
  if (babelResult && swcResult) {
    const speedup = babelResult.duration / swcResult.duration;
    const timeSaved = (babelResult.duration - swcResult.duration) / 1000;
    
    console.log(`\nüéØ ÏÑ±Îä• Î∂ÑÏÑù`);
    console.log(`   üìà ÏÜçÎèÑ Ìñ•ÏÉÅ: SWCÍ∞Ä ${speedup.toFixed(1)}Î∞∞ Îπ†Î¶Ñ`);
    console.log(`   ‚è∞ ÏãúÍ∞Ñ Ï†àÏïΩ: ${timeSaved.toFixed(1)}Ï¥à`);
    
    // Ï≤¥Í∞êÎèÑ Î∂ÑÏÑù
    if (speedup >= 10) {
      console.log(`   üöÄ ${speedup.toFixed(0)}Î∞∞ Ï∞®Ïù¥Îäî ÌòÅÏã†Ï†ÅÏù∏ ÏàòÏ§Ä!`);
    } else if (speedup >= 5) {
      console.log(`   üî• ${speedup.toFixed(0)}Î∞∞ Ï∞®Ïù¥Îäî ÌôïÏã§Ìûà Ï≤¥Í∞êÎêòÎäî ÏàòÏ§Ä!`);
    } else if (speedup >= 2) {
      console.log(`   ‚ö° ${speedup.toFixed(1)}Î∞∞ Ï∞®Ïù¥Îäî Í∞úÎ∞ú Í≤ΩÌóòÏùÑ Í∞úÏÑ†ÏãúÌÇ¥`);
    } else {
      console.log(`   üìä ${speedup.toFixed(1)}Î∞∞ Ï∞®Ïù¥Îäî ÎØ∏ÎØ∏ÌïòÏßÄÎßå ÎàÑÏ†ÅÎêòÎ©¥ ÏùòÎØ∏ÏûàÏùå`);
    }
    
    // Ïã§Î¨¥ Ï†ÅÏö© ÏãúÎÆ¨Î†àÏù¥ÏÖò
    console.log(`\nÏã§Î¨¥ ÏòÅÌñ• Î∂ÑÏÑù (ÌïòÎ£® 10Ìöå ÎπåÎìú Í∞ÄÏ†ï)`);
    const dailySavings = (timeSaved * 10) / 60; // Î∂Ñ Îã®ÏúÑ
    const weeklySavings = dailySavings * 5;
    const monthlySavings = weeklySavings * 4;
    
    console.log(`- ÏùºÏùº Ï†àÏïΩ: ${dailySavings.toFixed(1)}Î∂Ñ`);
    console.log(`- Ï£ºÍ∞Ñ Ï†àÏïΩ: ${weeklySavings.toFixed(1)}Î∂Ñ`);
    console.log(`- ÏõîÍ∞Ñ Ï†àÏïΩ: ${monthlySavings.toFixed(1)}Î∂Ñ (${(monthlySavings / 60).toFixed(1)}ÏãúÍ∞Ñ)`);
  }
}

// Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
async function main() {
  console.log('üöÄ JavaScript vs Native ÎèÑÍµ¨ ÏÑ±Îä• ÎπÑÍµê Î≤§ÏπòÎßàÌÅ¨\n');
  
  // ÌïÑÏöîÌïú Ìå®ÌÇ§ÏßÄ ÏÑ§Ïπò ÌôïÏù∏
  console.log('1. ÏÑ§ÏπòÎêú Ìå®ÌÇ§ÏßÄ ÌôïÏù∏ Ï§ë...');
  try {
    execSync('npx babel --version && npx swc --version', { stdio: 'pipe' });
    console.log('‚úÖ BabelÍ≥º SWCÍ∞Ä ÏÑ§ÏπòÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
  } catch (error) {
    console.error('‚ùå Babel ÎòêÎäî SWCÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    console.log('Îã§Ïùå Î™ÖÎ†πÏñ¥Î°ú ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî:');
    console.log('npm install --save-dev @babel/cli @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript @babel/plugin-transform-class-properties @babel/plugin-transform-runtime @swc/cli @swc/core');
    process.exit(1);
  }
  
  // Í∞ÄÏßú ÌååÏùº ÏÉùÏÑ±
  generateFakeTypescriptFiles();
  
  // Î≤§ÏπòÎßàÌÅ¨ Ïã§Ìñâ
  const babelResult = await benchmarkBabel();
  console.log(''); // Ï§ÑÎ∞îÍøà
  const swcResult = await benchmarkSWC();
  
  // Í≤∞Í≥º Ï∂úÎ†•
  printResults(babelResult, swcResult);
  
  // Ï†ïÎ¶¨
  console.log('\n4. ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨ Ï§ë...');
  fs.rmSync(CONFIG.outputDir, { recursive: true });
  fs.rmSync(CONFIG.babelOutputDir, { recursive: true });
  fs.rmSync(CONFIG.swcOutputDir, { recursive: true });
  if (fs.existsSync('./babel.config.json')) fs.unlinkSync('./babel.config.json');
  if (fs.existsSync('./.swcrc')) fs.unlinkSync('./.swcrc');
  
  console.log('‚úÖ Î≤§ÏπòÎßàÌÅ¨ ÏôÑÎ£å!');
}

// Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main, CONFIG };